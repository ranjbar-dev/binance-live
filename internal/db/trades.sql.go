// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: trades.sql

package db

import (
	"context"
)

const DeleteOldTrades = `-- name: DeleteOldTrades :exec
DELETE FROM trades 
WHERE timestamp < $1
`

func (q *Queries) DeleteOldTrades(ctx context.Context, timestamp int64) error {
	_, err := q.db.Exec(ctx, DeleteOldTrades, timestamp)
	return err
}

const GetLatestTrades = `-- name: GetLatestTrades :many
SELECT id, symbol, trade_id, timestamp, price, quantity, quote_quantity, is_buyer_maker, created_at
FROM trades
WHERE symbol = $1
ORDER BY timestamp DESC
LIMIT $2
`

type GetLatestTradesParams struct {
	Symbol string `db:"symbol" json:"symbol"`
	Limit  int32  `db:"limit" json:"limit"`
}

func (q *Queries) GetLatestTrades(ctx context.Context, arg GetLatestTradesParams) ([]Trade, error) {
	rows, err := q.db.Query(ctx, GetLatestTrades, arg.Symbol, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Trade{}
	for rows.Next() {
		var i Trade
		if err := rows.Scan(
			&i.ID,
			&i.Symbol,
			&i.TradeID,
			&i.Timestamp,
			&i.Price,
			&i.Quantity,
			&i.QuoteQuantity,
			&i.IsBuyerMaker,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetTradesByTimeRange = `-- name: GetTradesByTimeRange :many
SELECT id, symbol, trade_id, timestamp, price, quantity, quote_quantity, is_buyer_maker, created_at
FROM trades
WHERE symbol = $1
  AND timestamp >= $2 AND timestamp < $3
ORDER BY timestamp ASC
`

type GetTradesByTimeRangeParams struct {
	Symbol      string `db:"symbol" json:"symbol"`
	Timestamp   int64  `db:"timestamp" json:"timestamp"`
	Timestamp_2 int64  `db:"timestamp_2" json:"timestamp_2"`
}

func (q *Queries) GetTradesByTimeRange(ctx context.Context, arg GetTradesByTimeRangeParams) ([]Trade, error) {
	rows, err := q.db.Query(ctx, GetTradesByTimeRange, arg.Symbol, arg.Timestamp, arg.Timestamp_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Trade{}
	for rows.Next() {
		var i Trade
		if err := rows.Scan(
			&i.ID,
			&i.Symbol,
			&i.TradeID,
			&i.Timestamp,
			&i.Price,
			&i.Quantity,
			&i.QuoteQuantity,
			&i.IsBuyerMaker,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const InsertTrade = `-- name: InsertTrade :one
INSERT INTO trades (
    symbol, trade_id, timestamp, price, quantity, quote_quantity, is_buyer_maker
) VALUES ($1, $2, $3, $4, $5, $6, $7)
ON CONFLICT (symbol, trade_id, timestamp) DO UPDATE SET
    price = EXCLUDED.price,
    quantity = EXCLUDED.quantity,
    quote_quantity = EXCLUDED.quote_quantity,
    is_buyer_maker = EXCLUDED.is_buyer_maker
RETURNING id, created_at
`

type InsertTradeParams struct {
	Symbol        string  `db:"symbol" json:"symbol"`
	TradeID       int64   `db:"trade_id" json:"trade_id"`
	Timestamp     int64   `db:"timestamp" json:"timestamp"`
	Price         float64 `db:"price" json:"price"`
	Quantity      float64 `db:"quantity" json:"quantity"`
	QuoteQuantity float64 `db:"quote_quantity" json:"quote_quantity"`
	IsBuyerMaker  bool    `db:"is_buyer_maker" json:"is_buyer_maker"`
}

type InsertTradeRow struct {
	ID        int64 `db:"id" json:"id"`
	CreatedAt int64 `db:"created_at" json:"created_at"`
}

func (q *Queries) InsertTrade(ctx context.Context, arg InsertTradeParams) (InsertTradeRow, error) {
	row := q.db.QueryRow(ctx, InsertTrade,
		arg.Symbol,
		arg.TradeID,
		arg.Timestamp,
		arg.Price,
		arg.Quantity,
		arg.QuoteQuantity,
		arg.IsBuyerMaker,
	)
	var i InsertTradeRow
	err := row.Scan(&i.ID, &i.CreatedAt)
	return i, err
}
