// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: klines.sql

package db

import (
	"context"
)

const DeleteOldKlines = `-- name: DeleteOldKlines :exec
DELETE FROM klines 
WHERE open_time < $1
`

func (q *Queries) DeleteOldKlines(ctx context.Context, openTime int64) error {
	_, err := q.db.Exec(ctx, DeleteOldKlines, openTime)
	return err
}

const GetKlinesByTimeRange = `-- name: GetKlinesByTimeRange :many
SELECT symbol, interval, open_time, close_time, open_price, high_price,
       low_price, close_price, volume, quote_volume, trades_count,
       taker_buy_volume, taker_buy_quote_volume, created_at
FROM klines
WHERE symbol = $1 AND interval = $2
  AND open_time >= $3 AND open_time < $4
ORDER BY open_time ASC
`

type GetKlinesByTimeRangeParams struct {
	Symbol     string `db:"symbol" json:"symbol"`
	Interval   string `db:"interval" json:"interval"`
	OpenTime   int64  `db:"open_time" json:"open_time"`
	OpenTime_2 int64  `db:"open_time_2" json:"open_time_2"`
}

func (q *Queries) GetKlinesByTimeRange(ctx context.Context, arg GetKlinesByTimeRangeParams) ([]Kline, error) {
	rows, err := q.db.Query(ctx, GetKlinesByTimeRange,
		arg.Symbol,
		arg.Interval,
		arg.OpenTime,
		arg.OpenTime_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Kline{}
	for rows.Next() {
		var i Kline
		if err := rows.Scan(
			&i.Symbol,
			&i.Interval,
			&i.OpenTime,
			&i.CloseTime,
			&i.OpenPrice,
			&i.HighPrice,
			&i.LowPrice,
			&i.ClosePrice,
			&i.Volume,
			&i.QuoteVolume,
			&i.TradesCount,
			&i.TakerBuyVolume,
			&i.TakerBuyQuoteVolume,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetLastKline = `-- name: GetLastKline :one
SELECT symbol, interval, open_time, close_time, open_price, high_price,
       low_price, close_price, volume, quote_volume, trades_count,
       taker_buy_volume, taker_buy_quote_volume, created_at
FROM klines
WHERE symbol = $1 AND interval = $2
ORDER BY open_time DESC
LIMIT 1
`

type GetLastKlineParams struct {
	Symbol   string `db:"symbol" json:"symbol"`
	Interval string `db:"interval" json:"interval"`
}

func (q *Queries) GetLastKline(ctx context.Context, arg GetLastKlineParams) (Kline, error) {
	row := q.db.QueryRow(ctx, GetLastKline, arg.Symbol, arg.Interval)
	var i Kline
	err := row.Scan(
		&i.Symbol,
		&i.Interval,
		&i.OpenTime,
		&i.CloseTime,
		&i.OpenPrice,
		&i.HighPrice,
		&i.LowPrice,
		&i.ClosePrice,
		&i.Volume,
		&i.QuoteVolume,
		&i.TradesCount,
		&i.TakerBuyVolume,
		&i.TakerBuyQuoteVolume,
		&i.CreatedAt,
	)
	return i, err
}

const GetLatestKlines = `-- name: GetLatestKlines :many
SELECT symbol, interval, open_time, close_time, open_price, high_price,
       low_price, close_price, volume, quote_volume, trades_count,
       taker_buy_volume, taker_buy_quote_volume, created_at
FROM klines
WHERE symbol = $1 AND interval = $2
ORDER BY open_time DESC
LIMIT $3
`

type GetLatestKlinesParams struct {
	Symbol   string `db:"symbol" json:"symbol"`
	Interval string `db:"interval" json:"interval"`
	Limit    int32  `db:"limit" json:"limit"`
}

func (q *Queries) GetLatestKlines(ctx context.Context, arg GetLatestKlinesParams) ([]Kline, error) {
	rows, err := q.db.Query(ctx, GetLatestKlines, arg.Symbol, arg.Interval, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Kline{}
	for rows.Next() {
		var i Kline
		if err := rows.Scan(
			&i.Symbol,
			&i.Interval,
			&i.OpenTime,
			&i.CloseTime,
			&i.OpenPrice,
			&i.HighPrice,
			&i.LowPrice,
			&i.ClosePrice,
			&i.Volume,
			&i.QuoteVolume,
			&i.TradesCount,
			&i.TakerBuyVolume,
			&i.TakerBuyQuoteVolume,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const InsertKline = `-- name: InsertKline :exec
INSERT INTO klines (
    symbol, interval, open_time, close_time, open_price, high_price,
    low_price, close_price, volume, quote_volume, trades_count,
    taker_buy_volume, taker_buy_quote_volume
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
ON CONFLICT (symbol, interval, open_time) DO UPDATE SET
    close_time = EXCLUDED.close_time,
    open_price = EXCLUDED.open_price,
    high_price = EXCLUDED.high_price,
    low_price = EXCLUDED.low_price,
    close_price = EXCLUDED.close_price,
    volume = EXCLUDED.volume,
    quote_volume = EXCLUDED.quote_volume,
    trades_count = EXCLUDED.trades_count,
    taker_buy_volume = EXCLUDED.taker_buy_volume,
    taker_buy_quote_volume = EXCLUDED.taker_buy_quote_volume
`

type InsertKlineParams struct {
	Symbol              string  `db:"symbol" json:"symbol"`
	Interval            string  `db:"interval" json:"interval"`
	OpenTime            int64   `db:"open_time" json:"open_time"`
	CloseTime           int64   `db:"close_time" json:"close_time"`
	OpenPrice           float64 `db:"open_price" json:"open_price"`
	HighPrice           float64 `db:"high_price" json:"high_price"`
	LowPrice            float64 `db:"low_price" json:"low_price"`
	ClosePrice          float64 `db:"close_price" json:"close_price"`
	Volume              float64 `db:"volume" json:"volume"`
	QuoteVolume         float64 `db:"quote_volume" json:"quote_volume"`
	TradesCount         int32   `db:"trades_count" json:"trades_count"`
	TakerBuyVolume      float64 `db:"taker_buy_volume" json:"taker_buy_volume"`
	TakerBuyQuoteVolume float64 `db:"taker_buy_quote_volume" json:"taker_buy_quote_volume"`
}

func (q *Queries) InsertKline(ctx context.Context, arg InsertKlineParams) error {
	_, err := q.db.Exec(ctx, InsertKline,
		arg.Symbol,
		arg.Interval,
		arg.OpenTime,
		arg.CloseTime,
		arg.OpenPrice,
		arg.HighPrice,
		arg.LowPrice,
		arg.ClosePrice,
		arg.Volume,
		arg.QuoteVolume,
		arg.TradesCount,
		arg.TakerBuyVolume,
		arg.TakerBuyQuoteVolume,
	)
	return err
}
