// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sync_status.sql

package db

import (
	"context"
	"database/sql"
)

const DeleteSyncStatus = `-- name: DeleteSyncStatus :exec
DELETE FROM sync_status 
WHERE symbol = $1 AND data_type = $2 AND COALESCE(interval, '') = COALESCE($3, '')
`

type DeleteSyncStatusParams struct {
	Symbol   string         `db:"symbol" json:"symbol"`
	DataType string         `db:"data_type" json:"data_type"`
	Interval sql.NullString `db:"interval" json:"interval"`
}

func (q *Queries) DeleteSyncStatus(ctx context.Context, arg DeleteSyncStatusParams) error {
	_, err := q.db.Exec(ctx, DeleteSyncStatus, arg.Symbol, arg.DataType, arg.Interval)
	return err
}

const GetAllSyncStatuses = `-- name: GetAllSyncStatuses :many
SELECT s.symbol, s.data_type, s.interval, s.last_sync_time, s.last_data_time,
       s.status, s.error_message, s.updated_at
FROM sync_status s
INNER JOIN symbols sym ON s.symbol = sym.symbol
WHERE sym.is_active = true
ORDER BY s.symbol, s.data_type, s.interval
`

func (q *Queries) GetAllSyncStatuses(ctx context.Context) ([]SyncStatus, error) {
	rows, err := q.db.Query(ctx, GetAllSyncStatuses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SyncStatus{}
	for rows.Next() {
		var i SyncStatus
		if err := rows.Scan(
			&i.Symbol,
			&i.DataType,
			&i.Interval,
			&i.LastSyncTime,
			&i.LastDataTime,
			&i.Status,
			&i.ErrorMessage,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetSyncStatus = `-- name: GetSyncStatus :one
SELECT symbol, data_type, interval, last_sync_time, last_data_time,
       status, error_message, updated_at
FROM sync_status
WHERE symbol = $1 AND data_type = $2 AND COALESCE(interval, '') = COALESCE($3, '')
`

type GetSyncStatusParams struct {
	Symbol   string         `db:"symbol" json:"symbol"`
	DataType string         `db:"data_type" json:"data_type"`
	Interval sql.NullString `db:"interval" json:"interval"`
}

func (q *Queries) GetSyncStatus(ctx context.Context, arg GetSyncStatusParams) (SyncStatus, error) {
	row := q.db.QueryRow(ctx, GetSyncStatus, arg.Symbol, arg.DataType, arg.Interval)
	var i SyncStatus
	err := row.Scan(
		&i.Symbol,
		&i.DataType,
		&i.Interval,
		&i.LastSyncTime,
		&i.LastDataTime,
		&i.Status,
		&i.ErrorMessage,
		&i.UpdatedAt,
	)
	return i, err
}

const GetSyncStatusesBySymbol = `-- name: GetSyncStatusesBySymbol :many
SELECT symbol, data_type, interval, last_sync_time, last_data_time,
       status, error_message, updated_at
FROM sync_status
WHERE symbol = $1
ORDER BY data_type, interval
`

func (q *Queries) GetSyncStatusesBySymbol(ctx context.Context, symbol string) ([]SyncStatus, error) {
	rows, err := q.db.Query(ctx, GetSyncStatusesBySymbol, symbol)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SyncStatus{}
	for rows.Next() {
		var i SyncStatus
		if err := rows.Scan(
			&i.Symbol,
			&i.DataType,
			&i.Interval,
			&i.LastSyncTime,
			&i.LastDataTime,
			&i.Status,
			&i.ErrorMessage,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateLastDataTime = `-- name: UpdateLastDataTime :exec
UPDATE sync_status
SET last_data_time = $4,
    last_sync_time = EXTRACT(EPOCH FROM NOW()) * 1000,
    status = 'active',
    error_message = NULL,
    updated_at = EXTRACT(EPOCH FROM NOW()) * 1000
WHERE symbol = $1 AND data_type = $2 AND COALESCE(interval, '') = COALESCE($3, '')
`

type UpdateLastDataTimeParams struct {
	Symbol       string         `db:"symbol" json:"symbol"`
	DataType     string         `db:"data_type" json:"data_type"`
	Interval     sql.NullString `db:"interval" json:"interval"`
	LastDataTime int64          `db:"last_data_time" json:"last_data_time"`
}

func (q *Queries) UpdateLastDataTime(ctx context.Context, arg UpdateLastDataTimeParams) error {
	_, err := q.db.Exec(ctx, UpdateLastDataTime,
		arg.Symbol,
		arg.DataType,
		arg.Interval,
		arg.LastDataTime,
	)
	return err
}

const UpsertSyncStatus = `-- name: UpsertSyncStatus :exec
INSERT INTO sync_status (
    symbol, data_type, interval, last_sync_time, last_data_time, status, error_message
) VALUES ($1, $2, $3, $4, $5, $6, $7)
ON CONFLICT (symbol, data_type, interval) DO UPDATE SET
    last_sync_time = EXCLUDED.last_sync_time,
    last_data_time = EXCLUDED.last_data_time,
    status = EXCLUDED.status,
    error_message = EXCLUDED.error_message,
    updated_at = EXTRACT(EPOCH FROM NOW()) * 1000
`

type UpsertSyncStatusParams struct {
	Symbol       string         `db:"symbol" json:"symbol"`
	DataType     string         `db:"data_type" json:"data_type"`
	Interval     sql.NullString `db:"interval" json:"interval"`
	LastSyncTime int64          `db:"last_sync_time" json:"last_sync_time"`
	LastDataTime int64          `db:"last_data_time" json:"last_data_time"`
	Status       string         `db:"status" json:"status"`
	ErrorMessage sql.NullString `db:"error_message" json:"error_message"`
}

func (q *Queries) UpsertSyncStatus(ctx context.Context, arg UpsertSyncStatusParams) error {
	_, err := q.db.Exec(ctx, UpsertSyncStatus,
		arg.Symbol,
		arg.DataType,
		arg.Interval,
		arg.LastSyncTime,
		arg.LastDataTime,
		arg.Status,
		arg.ErrorMessage,
	)
	return err
}
